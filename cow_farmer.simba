{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
{$I WaspLib/osr/handlers/combathandler.simba}
{$I DoorHandler/doorhandler.simba}

{$DEFINE SCRIPT_GUI}

type
  ECowFarmerState = (
    ATTACK_COW,
    COW_COMBAT,
    PICK_UP,
    OUT_OF_PEN,
    WALK_TO_BANK,
    BANK_HIDES,
    WALK_TO_PEN,
    LOST
  );

  TCowFarmer = record(TBaseBankScript)
    State: ECowFarmerState;
    SeenXPOnAttack: Boolean;
    NorthGateHandler: DoorHandler;
    BankBox: TBox;
    PenBox: TBox;
    InsideGatePos: TPoint;
    OutsideGatePos: TPoint;
    CenterPenPos: TPoint;
    PathToBank: TPointArray;
    PathToPen: TPointArray;
    Cowhide: TRSItem;
    HideCount: Int32;
    CustomBank: TRSObject;
    LootInCombat: Boolean;
    CowhideColor: TCTS2Color;
  end;

procedure TAntiban.Setup(); override;
begin
  //Self.Skills := [ERSSkill.TOTAL, ERSSkill.RANGE];
  Self.MinZoom := 20;
  Self.MaxZoom := 40;

  Self.Skills := [
    ERSSkill.HITPOINTS,
    ERSSkill.PRAYER,
    ERSSkill.TOTAL
  ];

  inherited;
end;

function TCowFarmer.GetCustomCow(): TRSMonster;
var
  CustomCow: TRSMonster;
begin
  CustomCow.Setup(55, 4, [[PenBox.x1 + 16, PenBox.y1 + 16], [PenBox.x2 - 12, PenBox.y2 - 12], [PenBox.x1 - 12, PenBox.y1 + 12], [PenBox.x2 + 12, PenBox.y2 - 12]]);
  CustomCow.Setup('Cow');
  CustomCow.UpText += 'Cow calf';
  CustomCow.Finder.Colors += CTS2(1452592, 10);
  CustomCow.Finder.Colors += CTS2(5463667, 10);
  CustomCow.Finder.Colors += CTS2(5529974, 10);
  CustomCow.Finder.Colors += CTS2(13092814, 10);
  CustomCow.Finder.Colors += CTS2(5005930, 10);
  Result := CustomCow;
end;

function TCowFarmer.GetCustomBank(): TRSObject;
var
  CustomBank: TRSObject;
begin
  CustomBank.Setup(7, [[7432, 3032], [7436, 3032], [7440, 3032], [7444, 3032], [7448, 3032], [7452, 3032]]);
  CustomBank.Setup(['ank b', 'k booth']);
  CustomBank.Finder.Colors += CTS2(3099996, 17, 0.12, 0.59);
  CustomBank.Finder.Colors += CTS2(4086642, 5, 0.08, 0.55);
  Result := CustomBank;
end;

procedure TCowFarmer.Init(maxActions: Int32; maxTime: Int64); override;
begin
  inherited;

  Self.RSW.Setup('world');

  Self.BankBox := Box(7420, 3012, 7460, 3028);
  Self.PenBox := Box(7476, 3196, 7564, 3260);
  Self.OutsideGatePos := Point(7520, 3192);
  Self.InsideGatePos := Point(7520, 3196);
  Self.CenterPenPos := Point(7516, 3220);
  Self.PathToBank := [Point(7492, 3176), Point(7448, 3172), Point(7424, 3160), Point(7420, 3100), Point(7420, 3012), Point(7440, 3012), Point(7440, 3024)];
  Self.PathToPen := [Point(7440, 3024), Point(7440, 3012), Point(7420, 3012), Point(7420, 3100), Point(7424, 3160), Point(7448, 3172), Point(7492, 3176)];

  NorthGateHandler.Setup('North Gate Handler', GATE_2, [Point(7520, 3196), Point(7520, 3192)], [Point(7516, 3188), Point(7512, 3188)], Self.RSW);

  Self.Cowhide := 'Cowhide';
  Self.CustomBank := Self.GetCustomBank();

  Self.LootInCombat := True;
  Self.CowhideColor := CTS2(13092814, 10);

  CombatHandler.Setup(True, Self.GetCustomCow(), 10, 2000);
  Options.SetNPCAttackOption(ERSAttackOption.ALWAYS_LEFT_CLICK);
  Combat.SetAutoRetaliate(True);
end;

procedure TCowFarmer.AttackCow();
begin
  if CombatHandler.WalkAttackMonster() then
  begin
    Self.State := COW_COMBAT;
    Self.SeenXPOnAttack := False;
  end;
end;

procedure TCowFarmer.HandleInCombat();
var
  slots: TIntegerArray;
begin
  if Antiban.BioDice() then
    Self.RSW.CheckRunEnergy();
  if Antiban.BioDice() and Inventory.FindItems(REMAINS, slots) then
    Self.HandleBones();

  if Self.LootInCombat then
  begin
    WaitUntil(not Self.InCombat(), 100, 2000);
    if Self.InCombat() and Antiban.BioDice() then
    begin
      if CombatHandler.LootHandler.CheckLoot() then
      begin
        Minimap.WaitMoving(False);
        Wait(300, 500);
        while CombatHandler.LootHandler.CheckLoot(Self.RSW.GetMyTileMS()) do wait(200, 400);
        if Antiban.BioDice() then Self.HandleBones();
      end;
      WaitUntil(not Self.InCombat(), 100, 1000);
    end;
  end
  else begin
    WaitUntil(not Self.InCombat(), 100, 3000);
  end;
end;

procedure TCowFarmer.Loot();
var
  MyPos: TPoint;
  SearchBox: TBox;
  CowhidePoints: TPointArray;
  MaxChecks: Int32 := 3;
  Index: Int32 := 0;
  FoundLoot: Boolean := False;
begin
  MyPos := Self.RSW.GetMyTileMS();
  SearchBox := Box(MyPos.x - 40, MyPos.y - 40, MyPos.x + 40, MyPos.y + 40);
  SRL.FindColors(CowhidePoints, Self.CowhideColor, SearchBox);
  while (Index < Length(CowhidePoints)) and (Index < MaxChecks) and not FoundLoot do
  begin
    Mouse.Move(CowhidePoints[Index]);
    if MainScreen.GetUpText().StartsWith('Take') then
    begin
      FoundLoot := True;
      CombatHandler.LootHandler.HandleLooting();
      Minimap.WaitMoving(False);
      Wait(300, 500);
      while Antiban.BioDice() and CombatHandler.LootHandler.CheckLoot(Self.RSW.GetMyTileMS()) do Wait(200, 400);
    end;
    Index := Index + 1;
  end;
end;

procedure TCowFarmer.HandleBones();
var
  Done: Boolean;
begin
  while not Done do Done := not CombatHandler.DoBuryBones();
end;

procedure TCowFarmer.EnterPen();
begin
  Self.RSW.WalkPath([Self.OutsideGatePos], 5);
  Minimap.WaitMoving(False);
  if not Self.NorthGateHandler.IsOpen() then
  begin
    Self.NorthGateHandler.Open();
    Wait(500, 1000);
  end;
  Self.RSW.WalkPath([Self.CenterPenPos], 3);
end;

procedure TCowFarmer.ExitPen();
begin
  Self.RSW.WalkPath([Self.InsideGatePos], 5);
  Minimap.WaitMoving(False);
  if not Self.NorthGateHandler.IsOpen() then
  begin
    Self.NorthGateHandler.Open();
    Wait(500, 1000);
  end;
  Self.RSW.WalkPath([Self.OutsideGatePos]);
end;

procedure TCowFarmer.WalkToBank();
begin
  Self.ExitPen();
  Self.RSW.WalkPath(Self.PathToBank);
end;

procedure TCowFarmer.WalkToPen();
begin
  Self.RSW.WalkPath(Self.PathToPen);
  Self.EnterPen();
end;

procedure TCowFarmer.BankHides();
var
  InventoryHideCount: Int32;
begin
  if Bank.Hover(Self.CustomBank) then
  begin
    if Bank.WalkOpen(Self.CustomBank) then
    begin
      InventoryHideCount := Inventory.CountItem(Self.Cowhide);
      if Bank.DepositAll() then
      begin
        Self.HideCount := Self.HideCount + InventoryHideCount;
        Writeln(InventoryHideCount);
        Writeln('Total hides:');
        Writeln(Self.HideCount);
        Self.State := WALK_TO_PEN;
        WaitUntil(Inventory.Count() = 0, 100, 1000);
        Bank.Close(AntiBan.BioDice());
      end;
    end;
  end;
end;

procedure TCowFarmer.HandleLost();
var
  MyPos: TPoint;
  DistanceToBank: Double;
  DistanceToPen: Double;
begin
  MyPos := Self.RSW.GetMyPos();
  DistanceToBank := MyPos.DistanceTo(Self.PathToBank[Length(Self.PathToBank) - 1]);
  DistanceToPen := MyPos.DistanceTo(Self.CenterPenPos);
  if DistanceToPen > DistanceToBank then Self.RSW.WalkPath([Self.PathToBank[Length(Self.PathToBank) - 1]])
  else Self.EnterPen();
end;

function TCowFarmer.InCombat(): Boolean;
begin
  if not Self.SeenXPOnAttack then Self.SeenXPOnAttack := MainScreen.FindHitsplats() <> [];
  Result := MainScreen.InCombat();
end;

function TCowFarmer.GetState(): ECowFarmerState;
var
  PlayerPos: TPoint;
  InventoryIsFull: Boolean;
begin
  PlayerPos := Self.RSW.GetMyPos();
  InventoryisFull := Inventory.IsFull();

  if InventoryIsFull and PlayerPos.InBox(Self.PenBox) then Exit(WALK_TO_BANK);
  if InventoryIsFull and PlayerPos.InBox(Self.BankBox) then Exit(BANK_HIDES);
  if not InventoryIsFull and PlayerPos.InBox(Self.BankBox) then Exit(WALK_TO_PEN);

  if Self.InCombat() then Exit(COW_COMBAT);

  if not InventoryIsFull and PlayerPos.InBox(Self.PenBox) then
  begin
    if (Self.State = COW_COMBAT) and Self.SeenXPOnAttack then
    begin
      if not Self.InCombat() then
      begin
        Self.SeenXPOnAttack := False;
        Exit(PICK_UP);
      end;
      Exit(COW_COMBAT)
    end;

    Exit(ATTACK_COW);
  end;

  // We got lost, try to get back on track.
  Exit(LOST);
end;

procedure TCowFarmer.Run();
var
  OldState: ECowFarmerState;
begin
  Writeln(Self.RSW.GetMyPos);

  repeat
    if Inventory.IsFull() then Self.HandleBones();

    Self.State := Self.GetState();
    if not (Self.State = OldState) then
    begin
      Writeln Self.State;
      Self.DoAntiban();
    end;
    OldState := Self.State;
    case Self.State of
      ATTACK_COW: CombatHandler.AttackMonster();
      COW_COMBAT: Self.HandleInCombat();
      PICK_UP: Self.Loot();
      OUT_OF_PEN: Self.EnterPen();
      WALK_TO_BANK: Self.WalkToBank();
      BANK_HIDES: Self.BankHides();
      WALK_TO_PEN: Self.WalkToPen();
      LOST: Self.HandleLost();
    end;
  until Self.ShouldStop();

  Writeln(Self.BuildTextReport);
end;


{$IFDEF SCRIPT_GUI}
type
  TCowFarmerConfig = record(TScriptForm)
  SomeSelector: TLabeledCombobox;
  end;

procedure TCowFarmerConfig.Run(); override;
var
  tab: TTabSheet;
begin
  Self.Setup('Cow Farmer');
  Self.Start.setOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);

  Self.CreateVersionPanel(tab);
  Self.CreateAntibanManager();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;
{$ENDIF}



var
  CowFarmer: TCowFarmer;
{$IFDEF SCRIPT_GUI}
  CowFarmerConfig: TCowFarmerConfig
{$ENDIF}
begin
  {$IFDEF SCRIPT_GUI}
  CowFarmerConfig.Run();
  {$ENDIF}
  CowFarmer.Init(20, 7200000);

  CowFarmer.Run();
end;



function TRSWalker.GetMyTileMS(): TPoint;
var
  MyPos: TPoint;
begin
  MyPos := Self.GetMyPos();
  Exit(Self.GetTileMSEx(MyPos, MyPos).Mean());
end;

function MonsterData.GetDrops(monster: String): TRSMonsterDropArray; static; override;
var
  JSONArray: TJSONArray;
  i: Int32;
  drop: TRSMonsterDrop;
begin
  WriteLn('Loading ' + Monster + ' drops, this might take up to a 1 minute.');

  JSONArray := MonsterData.GetJSONArray(Monster, 'drops');

  for i := 0 to JSONArray.length() - 1 do
  begin
    drop := [];
    drop := MonsterData.GetDrop(JSONArray.getJSONObject(i));
    if drop.Item = 'raw beef' then continue;

    if not drop.Stackable then
    begin
      drop.Stackable := drop.ID.ContainsAny(['995', '996', '997', '998', '999', '1000', '1001', '1002', '1003', '1004']) or
                        ItemData.GetOSRSBoxBoolean(drop.ID, 'stackable');
    end;

    Result += Drop;
  end;
end;

function TRSMMDot._HoverHelper(Attempts: Int32): Boolean; override;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Filter.UpText and MainScreen.IsUpText(UpText) then
    Exit(True);

  if Filter.MinimapDot and (Minimap.GetDots(DotType) = []) then
    Exit;

  for Attempt := 0 to Attempts do
  begin
    if Self.Find(ATPA) then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else if Length(ATPA) > (Attempt - 2) then
        Points := ATPA[Attempt - 2]
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        if DotType = ERSMinimapDot.ITEM then
          Mouse.Move(Points.Mean)
        else
          Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if (DotType <> ERSMinimapDot.ITEM) and (Attempt = (Attempts - 1)) then
    begin
      CompassAngle := Minimap.GetCompassAngle + Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

